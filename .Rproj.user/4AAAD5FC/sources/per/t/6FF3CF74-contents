---
title: "Prep"
author: "Toyin Ola"
date: today
date-format: long
format: html
code-fold: true
toc: true
execute:
  echo: true
  warning: false
  include: true
  cache: false
params:
  state: "ok"
---

This is the preparation for a presentation on **`r toupper(params$state)`**.

# Set Up

Source the script with custom functions and load a few key packages that are used repeatedly. Note that a few other packages are used.

```{r set up}

# Source the functions script

source("functions.R")

# List required packages

packages <- c("sf", "dplyr", "tigris", "hereR", "here")

# Load required packages

invisible(lapply(packages, library, character.only = TRUE))

## See Stats and R blog post for more info on this efficient method: https://statsandr.com/blog/an-efficient-way-to-install-and-load-r-packages/

```

# Create New Directory

Create a new directory for the state using {fs}. 

```{r create base dir}

# Make a new folder with the state's name ----

base <- fs::dir_create(params$state)

```

# Download Hospital Data

Obtain data from Centers for Medicare and Medicaid Services Provider Data Catalog. 

```{r query PDC API}

# Query PDC API to obtain state's hospitals and save output ----

hospitals <- obtainHospitalData(params$state)

# Save output

write.csv(hospitals, 
          here(base,"raw_hospitals_data.csv")) 

```

```{r make and save no inpatient list}

# Identify the hospitals without inpatient L&D ----

no_inpatient <- hospitals |>  
  filter(stringr::str_detect(score, "does not provide inpatient labor")) |> 
  select(c(facility_id, facility_name))

# Save a copy

write.csv(no_inpatient, 
          here(base,"hospitals_without_inpatient.csv"))

```

```{r geocode hospitals}

# Clean up hospitals for geocoding ----

hospitals <- hospitals |> 
  mutate(inpatient = case_when(facility_id %in% no_inpatient$facility_id  ~ "No",
                               .default = "Yes")) |> 
  distinct(facility_id, .keep_all = TRUE) |> 
  mutate(full_address = paste0(address, ", ", citytown, ", ", state, " ", zip_code),
         .after = zip_code) |> 
  select(-c(telephone_number:end_date))

# Geocode hospitals location ----

hospitals <- hospitals |> 
  tidygeocoder::geocode(address = full_address, method = "arcgis") 

# Save a copy 

write.csv(hospitals, 
          here(base, "hospitals_geocoded.csv"))
```

```{r convert to sf object}

# Convert to sf object ----

hospitals_sf <- hospitals |>
  st_as_sf(coords = c("long", "lat"), 
           crs = 4269) # use planar projection

# Save as GPKG

st_write(obj = hospitals_sf, 
         dsn = paste0(base, "/", params$state, ".gpkg"),
         layer = "hospitals")

```

# Download and Tailor Geographic Boundaries

## Counties

Download county boundaries for given state. Note that the default CRS for {tigris} downloads is EPSG:4269 (NAD83), which is a planar projection. The CRS will have to be changed to EPSG:4326[^1] when using {leaflet}. 

[^1]: If interested, there is an [{sf} FAQ](https://r-spatial.github.io/sf/articles/sf6.html#why-should-we-use-ogccrs84-instead-of-epsg4326) on the potential ambiguity caused by EPSG:4326.

```{r download and save counties}

# Download county boundaries ----

counties <- counties(state = c(params$state), 
                     cb = TRUE, 
                     resolution = "500k", 
                     year = 2023)|> 
  select(-c(LSAD, ALAND, AWATER))

# Save to GPKG

st_write(obj = counties, 
         dsn = paste0(base, "/", params$state, ".gpkg"), 
         layer = "counties")

```

## Native Lands

Isolate native lands that are within the state. All of the native lands in the U.S. download at once through {tigris}, so they have been saved as a geopackage in the base folder. 

```{r clip native lands}

# Read in native lands GPKG ----

native_lands <- st_read(dsn = "data/native_lands.gpkg")

# Clip native lands to given state ----

clipped_native_lands <- st_intersection(counties, native_lands)

clipped_native_lands <- clipped_native_lands |> 
  rename(Tribe = NAME.1,
         Native_Land = NAMELSAD.1)

# Save to GPKG

st_write(obj = clipped_native_lands,
         dsn = paste0(base, "/", params$state, ".gpkg"), 
         layer = "native_lands")

```

## Isochrones

Query HERE API to obtain isochrones for the state's hospitals using a function created by [Hannah Recht](https://www.hrecht.com/r-drive-time-analysis-tutorial/tutorial.html). Ensure the API key is stored in [.Renviron file](https://laurenilano.com/posts/api-keys/).

```{r query HERE API}

# Set HERE API key ----

set_key(Sys.getenv("HERE_API_KEY"))

# Loop over points to make isochrones file ---

isochrones <- vector(mode = "list", length = nrow(hospitals_sf))
error_rows <- vector(mode = "list", length = nrow(hospitals_sf))

for (i in 1:nrow(hospitals_sf)) {
  
    print(i)
  
    # get isochrones for that point, using delay to avoid rate limiting
    Sys.sleep(0.9)
    
    ## filter to ith point
    point_temp <- hospitals_sf %>% filter(row_number() == i)
    point_id <- point_temp$facility_id
    
    isochrones_temp <- tryLocation(point_temp)
    
    # save any errored out points
    if (is.null(isochrones_temp)) {
        error_rows <- bind_rows(error_rows, point_temp)
    } else {
        isochrones <- bind_rows(isochrones, isochrones_temp)    
    }
}

## Save portions due to rate limiting issues... 
# 
# part_one <- isochrones
# 
# hospitals_sf <- hospitals_sf[70:125,]
# 
# part_two <- isochrones
# 
# hospitals_sf <- hospitals_sf[103:125,]
# 
# part_three <- isochrones
# 
# isochrones <- bind_rows(part_one, part_two) |> 
#   bind_rows(part_three)
# 
# setdiff(hospitals_sf$facility_id, 
#         isochrones_data$facility_id) # see if any were missed after left_join
# 
# part_four <- isochrones
# 
# isochrones <- bind_rows(part_one, part_two) |> 
#   bind_rows(part_three) |> 
#   bind_rows(part_four)

## Convert hospital sf object into df

hospitals_df <- hospitals_sf |> 
  st_drop_geometry() |> 
  as.data.frame() 

## Left join the isochrones sf object and hospitals df

isochrones_data <- isochrones |> 
  left_join(hospitals_df, by = "facility_id") 

## Remove extraneous columns

isochrones_data <- isochrones_data |> 
  select(-c(id:range))

## Save as GPKG

st_write(
  obj = isochrones_data, 
  dsn = paste0(base, "/", params$state, ".gpkg"), 
  layer = "isochrones"
)

```

